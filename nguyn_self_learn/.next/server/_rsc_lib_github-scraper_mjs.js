"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_github-scraper_mjs";
exports.ids = ["_rsc_lib_github-scraper_mjs"];
exports.modules = {

/***/ "(rsc)/./lib/github-scraper.mjs":
/*!********************************!*\
  !*** ./lib/github-scraper.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrapeGitHubProfile: () => (/* binding */ scrapeGitHubProfile)\n/* harmony export */ });\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dotenv */ \"(rsc)/./node_modules/dotenv/lib/main.js\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! url */ \"url\");\n\n\n\n\n\n// Load environment variables from .env file (optional, won't error if missing)\ndotenv__WEBPACK_IMPORTED_MODULE_0__.config();\n// Get the directory of the current module\nconst __filename = (0,url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)(\"file:///D:/lyrathon/nguyn_self_learn/lib/github-scraper.mjs\");\nconst __dirname = (0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(__filename);\n// GitHub API base URL\nconst GITHUB_API_BASE = \"https://api.github.com\";\n/**\r\n * Extract username from GitHub profile URL or return username directly\r\n */ function extractUsername(input) {\n    if (!input || typeof input !== \"string\" || input.trim().length === 0) {\n        throw new Error(\"Input is required\");\n    }\n    const trimmed = input.trim();\n    // If it's a URL, extract username\n    if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n        if (!trimmed.includes(\"github.com\")) {\n            throw new Error(\"URL must be a GitHub profile URL\");\n        }\n        const match = trimmed.match(/github\\.com\\/([^\\/\\?#]+)/);\n        if (!match || !match[1]) {\n            throw new Error(\"Could not extract username from URL\");\n        }\n        return match[1];\n    }\n    return trimmed.startsWith(\"@\") ? trimmed.slice(1) : trimmed;\n}\n/**\r\n * Make a request to GitHub API\r\n */ async function fetchGitHubAPI(endpoint, token = null) {\n    const url = `${GITHUB_API_BASE}${endpoint}`;\n    const headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"User-Agent\": \"GitHub-Profile-Scraper\"\n    };\n    if (token) {\n        headers[\"Authorization\"] = `token ${token}`;\n    }\n    const response = await fetch(url, {\n        headers\n    });\n    if (!response.ok) {\n        if (response.status === 404) {\n            throw new Error(`GitHub user or resource not found: ${endpoint}`);\n        }\n        if (response.status === 403) {\n            throw new Error(\"GitHub API rate limit exceeded. Consider using a GitHub personal access token.\");\n        }\n        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);\n    }\n    return response.json();\n}\n/**\r\n * Fetch all pages from a paginated GitHub API endpoint\r\n */ async function fetchAllPages(endpoint, token = null) {\n    const allItems = [];\n    let page = 1;\n    const perPage = 100;\n    while(true){\n        const separator = endpoint.includes(\"?\") ? \"&\" : \"?\";\n        const paginatedEndpoint = `${endpoint}${separator}page=${page}&per_page=${perPage}`;\n        const items = await fetchGitHubAPI(paginatedEndpoint, token);\n        if (!Array.isArray(items) || items.length === 0) {\n            break;\n        }\n        allItems.push(...items);\n        if (items.length < perPage) {\n            break;\n        }\n        page++;\n    }\n    return allItems;\n}\n/**\r\n * Fetch repo languages\r\n */ async function fetchRepoLanguages(repo, token) {\n    try {\n        const languagesUrl = repo.languages_url;\n        const endpoint = languagesUrl.replace(GITHUB_API_BASE, \"\");\n        const languages = await fetchGitHubAPI(endpoint, token);\n        return languages;\n    } catch (error) {\n        return {};\n    }\n}\n/**\r\n * Fetch root-level file names\r\n */ async function fetchRootFiles(repo, token) {\n    try {\n        const contentsUrl = repo.contents_url.replace(\"{+path}\", \"\");\n        const endpoint = contentsUrl.replace(GITHUB_API_BASE, \"\");\n        const contents = await fetchGitHubAPI(endpoint, token);\n        if (Array.isArray(contents)) {\n            return contents.filter((item)=>item.type === \"file\").map((item)=>item.name);\n        }\n        return [];\n    } catch (error) {\n        return [];\n    }\n}\n/**\r\n * Fetch last 20 commits\r\n */ async function fetchRecentCommits(repo, token) {\n    try {\n        const commitsUrl = repo.commits_url.replace(\"{/sha}\", \"\");\n        const endpoint = commitsUrl.replace(GITHUB_API_BASE, \"\");\n        const commits = await fetchGitHubAPI(`${endpoint}?per_page=20`, token);\n        if (Array.isArray(commits)) {\n            return commits.map((commit)=>({\n                    author: commit.author?.login || commit.commit?.author?.name || \"unknown\",\n                    date: commit.commit?.author?.date || commit.commit?.committer?.date || null,\n                    message: commit.commit?.message || \"\"\n                }));\n        }\n        return [];\n    } catch (error) {\n        return [];\n    }\n}\n/**\r\n * Fetch dependencies from common dependency files\r\n */ async function fetchDependencies(repo, token) {\n    try {\n        const contentsUrl = repo.contents_url.replace(\"{+path}\", \"\");\n        const endpoint = contentsUrl.replace(GITHUB_API_BASE, \"\");\n        const contents = await fetchGitHubAPI(endpoint, token);\n        if (!Array.isArray(contents)) {\n            return null;\n        }\n        const dependencies = [];\n        const dependencyFiles = [\n            {\n                name: \"package.json\",\n                type: \"npm\"\n            },\n            {\n                name: \"requirements.txt\",\n                type: \"python\"\n            },\n            {\n                name: \"Pipfile\",\n                type: \"python\"\n            },\n            {\n                name: \"pom.xml\",\n                type: \"maven\"\n            },\n            {\n                name: \"build.gradle\",\n                type: \"gradle\"\n            },\n            {\n                name: \"Cargo.toml\",\n                type: \"rust\"\n            },\n            {\n                name: \"go.mod\",\n                type: \"go\"\n            }\n        ];\n        for (const depFile of dependencyFiles){\n            const file = contents.find((item)=>item.name === depFile.name && item.type === \"file\");\n            if (file && file.download_url) {\n                try {\n                    const fileContent = await fetch(file.download_url).then((r)=>r.text());\n                    if (depFile.type === \"npm\" && file.name === \"package.json\") {\n                        const pkg = JSON.parse(fileContent);\n                        const deps = {\n                            ...pkg.dependencies,\n                            ...pkg.devDependencies\n                        };\n                        dependencies.push(...Object.keys(deps));\n                    } else if (depFile.type === \"python\" && (file.name === \"requirements.txt\" || file.name === \"Pipfile\")) {\n                        const lines = fileContent.split(\"\\n\");\n                        for (const line of lines){\n                            const trimmed = line.trim();\n                            if (trimmed && !trimmed.startsWith(\"#\")) {\n                                const pkgName = trimmed.split(/[>=<!=]/)[0].trim();\n                                if (pkgName) dependencies.push(pkgName);\n                            }\n                        }\n                    }\n                } catch (err) {\n                // Skip if file can't be parsed\n                }\n            }\n        }\n        return dependencies.length > 0 ? dependencies : null;\n    } catch (error) {\n        return null;\n    }\n}\n/**\r\n * Fetch imports from common source files\r\n */ async function fetchImports(repo, token) {\n    try {\n        const contentsUrl = repo.contents_url.replace(\"{+path}\", \"\");\n        const endpoint = contentsUrl.replace(GITHUB_API_BASE, \"\");\n        const contents = await fetchGitHubAPI(endpoint, token);\n        if (!Array.isArray(contents)) {\n            return null;\n        }\n        const imports = new Set();\n        const sourceExtensions = [\n            \".js\",\n            \".ts\",\n            \".jsx\",\n            \".tsx\",\n            \".py\",\n            \".java\",\n            \".go\",\n            \".rs\"\n        ];\n        for (const item of contents){\n            if (item.type === \"file\" && sourceExtensions.some((ext)=>item.name.endsWith(ext))) {\n                try {\n                    if (item.download_url) {\n                        const fileContent = await fetch(item.download_url).then((r)=>r.text());\n                        const lines = fileContent.split(\"\\n\");\n                        for (const line of lines){\n                            const jsImport = line.match(/^(?:import|from)\\s+['\"]([^'\"]+)['\"]/);\n                            if (jsImport) imports.add(jsImport[1]);\n                            const pyImport = line.match(/^(?:import|from)\\s+([a-zA-Z0-9_.]+)/);\n                            if (pyImport) imports.add(pyImport[1].split(\".\")[0]);\n                            const javaImport = line.match(/^import\\s+([a-zA-Z0-9_.]+)/);\n                            if (javaImport) imports.add(javaImport[1]);\n                        }\n                    }\n                } catch (err) {\n                // Skip if file can't be read\n                }\n            }\n        }\n        return imports.size > 0 ? Array.from(imports).slice(0, 50) : null;\n    } catch (error) {\n        return null;\n    }\n}\n/**\r\n * Fetch README excerpt (first 2000 characters)\r\n */ async function fetchReadmeExcerpt(repo, token) {\n    try {\n        const contentsUrl = repo.contents_url.replace(\"{+path}\", \"\");\n        const endpoint = contentsUrl.replace(GITHUB_API_BASE, \"\");\n        const contents = await fetchGitHubAPI(endpoint, token);\n        if (!Array.isArray(contents)) {\n            return null;\n        }\n        const readmeFile = contents.find((item)=>item.type === \"file\" && (item.name.toLowerCase() === \"readme.md\" || item.name.toLowerCase() === \"readme\"));\n        if (!readmeFile) {\n            return null;\n        }\n        const readmeEndpoint = repo.contents_url.replace(\"{+path}\", \"README.md\");\n        const readmeEndpointPath = readmeEndpoint.replace(GITHUB_API_BASE, \"\");\n        const readmeData = await fetchGitHubAPI(readmeEndpointPath, token);\n        if (readmeData.content && readmeData.encoding === \"base64\") {\n            const content = Buffer.from(readmeData.content, \"base64\").toString(\"utf-8\");\n            return content.slice(0, 2000);\n        }\n        return null;\n    } catch (error) {\n        return null;\n    }\n}\n/**\r\n * Fetch evidence data for a single repo\r\n */ async function fetchRepoEvidence(repo, token) {\n    const languages = await fetchRepoLanguages(repo, token);\n    const rootFiles = await fetchRootFiles(repo, token);\n    const dependencies = await fetchDependencies(repo, token);\n    const imports = await fetchImports(repo, token);\n    const recentCommits = await fetchRecentCommits(repo, token);\n    const readmeExcerpt = await fetchReadmeExcerpt(repo, token);\n    return {\n        repo: {\n            name: repo.name,\n            url: repo.html_url,\n            fork: repo.fork,\n            pushed_at: repo.pushed_at\n        },\n        evidence: {\n            languages,\n            root_files: rootFiles,\n            dependencies,\n            imports,\n            recent_commits: recentCommits,\n            readme_excerpt: readmeExcerpt\n        }\n    };\n}\n/**\r\n * Scrape GitHub profile and return repositories data\r\n */ async function scrapeGitHubProfile(githubUrl, githubToken = null) {\n    const username = extractUsername(githubUrl);\n    const token = githubToken || process.env.GITHUB_TOKEN || null;\n    // Fetch repositories\n    const repos = await fetchAllPages(`/users/${username}/repos`, token);\n    // Fetch evidence for all repos\n    const repoEvidence = [];\n    for (const repo of repos){\n        try {\n            const evidence = await fetchRepoEvidence(repo, token);\n            repoEvidence.push(evidence);\n        } catch (error) {\n            repoEvidence.push({\n                repo: {\n                    name: repo.name,\n                    url: repo.html_url,\n                    fork: repo.fork,\n                    pushed_at: repo.pushed_at\n                },\n                evidence: null\n            });\n        }\n    }\n    // Build enriched repos\n    const evidenceMap = new Map();\n    for (const evidenceData of repoEvidence){\n        evidenceMap.set(evidenceData.repo.name, evidenceData);\n    }\n    const enrichedRepos = repos.map((repo)=>{\n        const evidenceData = evidenceMap.get(repo.name);\n        if (evidenceData) {\n            return evidenceData;\n        }\n        return {\n            repo: {\n                name: repo.name,\n                url: repo.html_url,\n                fork: repo.fork,\n                pushed_at: repo.pushed_at\n            },\n            evidence: null\n        };\n    });\n    return {\n        type: \"repositories\",\n        data: enrichedRepos\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNnRjtRQUNwQixFQUFFLE9BQU96RSxPQUFPO1lBQ2RxRixhQUFhNUYsSUFBSSxDQUFDO2dCQUNoQkUsTUFBTTtvQkFDSmMsTUFBTWQsS0FBS2MsSUFBSTtvQkFDZmhELEtBQUtrQyxLQUFLMkUsUUFBUTtvQkFDbEJDLE1BQU01RSxLQUFLNEUsSUFBSTtvQkFDZkMsV0FBVzdFLEtBQUs2RSxTQUFTO2dCQUMzQjtnQkFDQUMsVUFBVTtZQUNaO1FBQ0Y7SUFDRjtJQUVBLHVCQUF1QjtJQUN2QixNQUFNYSxjQUFjLElBQUlDO0lBQ3hCLEtBQUssTUFBTUMsZ0JBQWdCSCxhQUFjO1FBQ3ZDQyxZQUFZRyxHQUFHLENBQUNELGFBQWE3RixJQUFJLENBQUNjLElBQUksRUFBRStFO0lBQzFDO0lBRUEsTUFBTUUsZ0JBQWdCTixNQUFNNUUsR0FBRyxDQUFDYixDQUFBQTtRQUM5QixNQUFNNkYsZUFBZUYsWUFBWUssR0FBRyxDQUFDaEcsS0FBS2MsSUFBSTtRQUM5QyxJQUFJK0UsY0FBYztZQUNoQixPQUFPQTtRQUNUO1FBQ0EsT0FBTztZQUNMN0YsTUFBTTtnQkFDSmMsTUFBTWQsS0FBS2MsSUFBSTtnQkFDZmhELEtBQUtrQyxLQUFLMkUsUUFBUTtnQkFDbEJDLE1BQU01RSxLQUFLNEUsSUFBSTtnQkFDZkMsV0FBVzdFLEtBQUs2RSxTQUFTO1lBQzNCO1lBQ0FDLFVBQVU7UUFDWjtJQUNGO0lBRUEsT0FBTztRQUNMbEUsTUFBTTtRQUNOcUYsTUFBTUY7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2l0aHViLXByb2ZpbGUtc2NyYXBlci8uL2xpYi9naXRodWItc2NyYXBlci5tanM/ZWQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZG90ZW52IGZyb20gJ2RvdGVudic7XHJcbmltcG9ydCB7IHdyaXRlRmlsZSwgbWtkaXIsIHJlYWRGaWxlIH0gZnJvbSAnZnMvcHJvbWlzZXMnO1xyXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnO1xyXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XHJcblxyXG4vLyBMb2FkIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIC5lbnYgZmlsZSAob3B0aW9uYWwsIHdvbid0IGVycm9yIGlmIG1pc3NpbmcpXHJcbmRvdGVudi5jb25maWcoKTtcclxuXHJcbi8vIEdldCB0aGUgZGlyZWN0b3J5IG9mIHRoZSBjdXJyZW50IG1vZHVsZVxyXG5jb25zdCBfX2ZpbGVuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xyXG5jb25zdCBfX2Rpcm5hbWUgPSBkaXJuYW1lKF9fZmlsZW5hbWUpO1xyXG5cclxuLy8gR2l0SHViIEFQSSBiYXNlIFVSTFxyXG5jb25zdCBHSVRIVUJfQVBJX0JBU0UgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbSc7XHJcblxyXG4vKipcclxuICogRXh0cmFjdCB1c2VybmFtZSBmcm9tIEdpdEh1YiBwcm9maWxlIFVSTCBvciByZXR1cm4gdXNlcm5hbWUgZGlyZWN0bHlcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RVc2VybmFtZShpbnB1dCkge1xyXG4gIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyB8fCBpbnB1dC50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB0cmltbWVkID0gaW5wdXQudHJpbSgpO1xyXG5cclxuICAvLyBJZiBpdCdzIGEgVVJMLCBleHRyYWN0IHVzZXJuYW1lXHJcbiAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xyXG4gICAgaWYgKCF0cmltbWVkLmluY2x1ZGVzKCdnaXRodWIuY29tJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgbXVzdCBiZSBhIEdpdEh1YiBwcm9maWxlIFVSTCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL2dpdGh1YlxcLmNvbVxcLyhbXlxcL1xcPyNdKykvKTtcclxuICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzFdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgdXNlcm5hbWUgZnJvbSBVUkwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaFsxXTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJ0AnKSA/IHRyaW1tZWQuc2xpY2UoMSkgOiB0cmltbWVkO1xyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhIHJlcXVlc3QgdG8gR2l0SHViIEFQSVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hHaXRIdWJBUEkoZW5kcG9pbnQsIHRva2VuID0gbnVsbCkge1xyXG4gIGNvbnN0IHVybCA9IGAke0dJVEhVQl9BUElfQkFTRX0ke2VuZHBvaW50fWA7XHJcbiAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uJyxcclxuICAgICdVc2VyLUFnZW50JzogJ0dpdEh1Yi1Qcm9maWxlLVNjcmFwZXInLFxyXG4gIH07XHJcblxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYHRva2VuICR7dG9rZW59YDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IGhlYWRlcnMgfSk7XHJcblxyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdEh1YiB1c2VyIG9yIHJlc291cmNlIG5vdCBmb3VuZDogJHtlbmRwb2ludH1gKTtcclxuICAgIH1cclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdEh1YiBBUEkgcmF0ZSBsaW1pdCBleGNlZWRlZC4gQ29uc2lkZXIgdXNpbmcgYSBHaXRIdWIgcGVyc29uYWwgYWNjZXNzIHRva2VuLicpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBHaXRIdWIgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIGFsbCBwYWdlcyBmcm9tIGEgcGFnaW5hdGVkIEdpdEh1YiBBUEkgZW5kcG9pbnRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsUGFnZXMoZW5kcG9pbnQsIHRva2VuID0gbnVsbCkge1xyXG4gIGNvbnN0IGFsbEl0ZW1zID0gW107XHJcbiAgbGV0IHBhZ2UgPSAxO1xyXG4gIGNvbnN0IHBlclBhZ2UgPSAxMDA7XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBlbmRwb2ludC5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xyXG4gICAgY29uc3QgcGFnaW5hdGVkRW5kcG9pbnQgPSBgJHtlbmRwb2ludH0ke3NlcGFyYXRvcn1wYWdlPSR7cGFnZX0mcGVyX3BhZ2U9JHtwZXJQYWdlfWA7XHJcbiAgICBcclxuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgZmV0Y2hHaXRIdWJBUEkocGFnaW5hdGVkRW5kcG9pbnQsIHRva2VuKTtcclxuICAgIFxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGFsbEl0ZW1zLnB1c2goLi4uaXRlbXMpO1xyXG4gICAgXHJcbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgcGVyUGFnZSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcGFnZSsrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFsbEl0ZW1zO1xyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggcmVwbyBsYW5ndWFnZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVwb0xhbmd1YWdlcyhyZXBvLCB0b2tlbikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBsYW5ndWFnZXNVcmwgPSByZXBvLmxhbmd1YWdlc191cmw7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGxhbmd1YWdlc1VybC5yZXBsYWNlKEdJVEhVQl9BUElfQkFTRSwgJycpO1xyXG4gICAgY29uc3QgbGFuZ3VhZ2VzID0gYXdhaXQgZmV0Y2hHaXRIdWJBUEkoZW5kcG9pbnQsIHRva2VuKTtcclxuICAgIHJldHVybiBsYW5ndWFnZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaCByb290LWxldmVsIGZpbGUgbmFtZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUm9vdEZpbGVzKHJlcG8sIHRva2VuKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbnRlbnRzVXJsID0gcmVwby5jb250ZW50c191cmwucmVwbGFjZSgneytwYXRofScsICcnKTtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gY29udGVudHNVcmwucmVwbGFjZShHSVRIVUJfQVBJX0JBU0UsICcnKTtcclxuICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgZmV0Y2hHaXRIdWJBUEkoZW5kcG9pbnQsIHRva2VuKTtcclxuICAgIFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudHMpKSB7XHJcbiAgICAgIHJldHVybiBjb250ZW50c1xyXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdmaWxlJylcclxuICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5uYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIGxhc3QgMjAgY29tbWl0c1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWNlbnRDb21taXRzKHJlcG8sIHRva2VuKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbW1pdHNVcmwgPSByZXBvLmNvbW1pdHNfdXJsLnJlcGxhY2UoJ3svc2hhfScsICcnKTtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gY29tbWl0c1VybC5yZXBsYWNlKEdJVEhVQl9BUElfQkFTRSwgJycpO1xyXG4gICAgY29uc3QgY29tbWl0cyA9IGF3YWl0IGZldGNoR2l0SHViQVBJKGAke2VuZHBvaW50fT9wZXJfcGFnZT0yMGAsIHRva2VuKTtcclxuICAgIFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWl0cykpIHtcclxuICAgICAgcmV0dXJuIGNvbW1pdHMubWFwKGNvbW1pdCA9PiAoe1xyXG4gICAgICAgIGF1dGhvcjogY29tbWl0LmF1dGhvcj8ubG9naW4gfHwgY29tbWl0LmNvbW1pdD8uYXV0aG9yPy5uYW1lIHx8ICd1bmtub3duJyxcclxuICAgICAgICBkYXRlOiBjb21taXQuY29tbWl0Py5hdXRob3I/LmRhdGUgfHwgY29tbWl0LmNvbW1pdD8uY29tbWl0dGVyPy5kYXRlIHx8IG51bGwsXHJcbiAgICAgICAgbWVzc2FnZTogY29tbWl0LmNvbW1pdD8ubWVzc2FnZSB8fCAnJyxcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggZGVwZW5kZW5jaWVzIGZyb20gY29tbW9uIGRlcGVuZGVuY3kgZmlsZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGVwZW5kZW5jaWVzKHJlcG8sIHRva2VuKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbnRlbnRzVXJsID0gcmVwby5jb250ZW50c191cmwucmVwbGFjZSgneytwYXRofScsICcnKTtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gY29udGVudHNVcmwucmVwbGFjZShHSVRIVUJfQVBJX0JBU0UsICcnKTtcclxuICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgZmV0Y2hHaXRIdWJBUEkoZW5kcG9pbnQsIHRva2VuKTtcclxuICAgIFxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnRzKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBbXTtcclxuICAgIGNvbnN0IGRlcGVuZGVuY3lGaWxlcyA9IFtcclxuICAgICAgeyBuYW1lOiAncGFja2FnZS5qc29uJywgdHlwZTogJ25wbScgfSxcclxuICAgICAgeyBuYW1lOiAncmVxdWlyZW1lbnRzLnR4dCcsIHR5cGU6ICdweXRob24nIH0sXHJcbiAgICAgIHsgbmFtZTogJ1BpcGZpbGUnLCB0eXBlOiAncHl0aG9uJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwb20ueG1sJywgdHlwZTogJ21hdmVuJyB9LFxyXG4gICAgICB7IG5hbWU6ICdidWlsZC5ncmFkbGUnLCB0eXBlOiAnZ3JhZGxlJyB9LFxyXG4gICAgICB7IG5hbWU6ICdDYXJnby50b21sJywgdHlwZTogJ3J1c3QnIH0sXHJcbiAgICAgIHsgbmFtZTogJ2dvLm1vZCcsIHR5cGU6ICdnbycgfSxcclxuICAgIF07XHJcblxyXG4gICAgZm9yIChjb25zdCBkZXBGaWxlIG9mIGRlcGVuZGVuY3lGaWxlcykge1xyXG4gICAgICBjb25zdCBmaWxlID0gY29udGVudHMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gZGVwRmlsZS5uYW1lICYmIGl0ZW0udHlwZSA9PT0gJ2ZpbGUnKTtcclxuICAgICAgaWYgKGZpbGUgJiYgZmlsZS5kb3dubG9hZF91cmwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCBmZXRjaChmaWxlLmRvd25sb2FkX3VybCkudGhlbihyID0+IHIudGV4dCgpKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRlcEZpbGUudHlwZSA9PT0gJ25wbScgJiYgZmlsZS5uYW1lID09PSAncGFja2FnZS5qc29uJykge1xyXG4gICAgICAgICAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKGZpbGVDb250ZW50KTtcclxuICAgICAgICAgICAgY29uc3QgZGVwcyA9IHsgLi4ucGtnLmRlcGVuZGVuY2llcywgLi4ucGtnLmRldkRlcGVuZGVuY2llcyB9O1xyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCguLi5PYmplY3Qua2V5cyhkZXBzKSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlcEZpbGUudHlwZSA9PT0gJ3B5dGhvbicgJiYgKGZpbGUubmFtZSA9PT0gJ3JlcXVpcmVtZW50cy50eHQnIHx8IGZpbGUubmFtZSA9PT0gJ1BpcGZpbGUnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xyXG4gICAgICAgICAgICAgIGlmICh0cmltbWVkICYmICF0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGtnTmFtZSA9IHRyaW1tZWQuc3BsaXQoL1s+PTwhPV0vKVswXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGtnTmFtZSkgZGVwZW5kZW5jaWVzLnB1c2gocGtnTmFtZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAvLyBTa2lwIGlmIGZpbGUgY2FuJ3QgYmUgcGFyc2VkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcy5sZW5ndGggPiAwID8gZGVwZW5kZW5jaWVzIDogbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggaW1wb3J0cyBmcm9tIGNvbW1vbiBzb3VyY2UgZmlsZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoSW1wb3J0cyhyZXBvLCB0b2tlbikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb250ZW50c1VybCA9IHJlcG8uY29udGVudHNfdXJsLnJlcGxhY2UoJ3srcGF0aH0nLCAnJyk7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGNvbnRlbnRzVXJsLnJlcGxhY2UoR0lUSFVCX0FQSV9CQVNFLCAnJyk7XHJcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZldGNoR2l0SHViQVBJKGVuZHBvaW50LCB0b2tlbik7XHJcbiAgICBcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50cykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW1wb3J0cyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHNvdXJjZUV4dGVuc2lvbnMgPSBbJy5qcycsICcudHMnLCAnLmpzeCcsICcudHN4JywgJy5weScsICcuamF2YScsICcuZ28nLCAnLnJzJ107XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50cykge1xyXG4gICAgICBpZiAoaXRlbS50eXBlID09PSAnZmlsZScgJiYgc291cmNlRXh0ZW5zaW9ucy5zb21lKGV4dCA9PiBpdGVtLm5hbWUuZW5kc1dpdGgoZXh0KSkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGl0ZW0uZG93bmxvYWRfdXJsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgZmV0Y2goaXRlbS5kb3dubG9hZF91cmwpLnRoZW4ociA9PiByLnRleHQoKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QganNJbXBvcnQgPSBsaW5lLm1hdGNoKC9eKD86aW1wb3J0fGZyb20pXFxzK1snXCJdKFteJ1wiXSspWydcIl0vKTtcclxuICAgICAgICAgICAgICBpZiAoanNJbXBvcnQpIGltcG9ydHMuYWRkKGpzSW1wb3J0WzFdKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBweUltcG9ydCA9IGxpbmUubWF0Y2goL14oPzppbXBvcnR8ZnJvbSlcXHMrKFthLXpBLVowLTlfLl0rKS8pO1xyXG4gICAgICAgICAgICAgIGlmIChweUltcG9ydCkgaW1wb3J0cy5hZGQocHlJbXBvcnRbMV0uc3BsaXQoJy4nKVswXSk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc3QgamF2YUltcG9ydCA9IGxpbmUubWF0Y2goL15pbXBvcnRcXHMrKFthLXpBLVowLTlfLl0rKS8pO1xyXG4gICAgICAgICAgICAgIGlmIChqYXZhSW1wb3J0KSBpbXBvcnRzLmFkZChqYXZhSW1wb3J0WzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgLy8gU2tpcCBpZiBmaWxlIGNhbid0IGJlIHJlYWRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW1wb3J0cy5zaXplID4gMCA/IEFycmF5LmZyb20oaW1wb3J0cykuc2xpY2UoMCwgNTApIDogbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggUkVBRE1FIGV4Y2VycHQgKGZpcnN0IDIwMDAgY2hhcmFjdGVycylcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVhZG1lRXhjZXJwdChyZXBvLCB0b2tlbikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb250ZW50c1VybCA9IHJlcG8uY29udGVudHNfdXJsLnJlcGxhY2UoJ3srcGF0aH0nLCAnJyk7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGNvbnRlbnRzVXJsLnJlcGxhY2UoR0lUSFVCX0FQSV9CQVNFLCAnJyk7XHJcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZldGNoR2l0SHViQVBJKGVuZHBvaW50LCB0b2tlbik7XHJcbiAgICBcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50cykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVhZG1lRmlsZSA9IGNvbnRlbnRzLmZpbmQoaXRlbSA9PiBcclxuICAgICAgaXRlbS50eXBlID09PSAnZmlsZScgJiYgXHJcbiAgICAgIChpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWRtZS5tZCcgfHwgaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdyZWFkbWUnKVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXJlYWRtZUZpbGUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVhZG1lRW5kcG9pbnQgPSByZXBvLmNvbnRlbnRzX3VybC5yZXBsYWNlKCd7K3BhdGh9JywgJ1JFQURNRS5tZCcpO1xyXG4gICAgY29uc3QgcmVhZG1lRW5kcG9pbnRQYXRoID0gcmVhZG1lRW5kcG9pbnQucmVwbGFjZShHSVRIVUJfQVBJX0JBU0UsICcnKTtcclxuICAgIGNvbnN0IHJlYWRtZURhdGEgPSBhd2FpdCBmZXRjaEdpdEh1YkFQSShyZWFkbWVFbmRwb2ludFBhdGgsIHRva2VuKTtcclxuXHJcbiAgICBpZiAocmVhZG1lRGF0YS5jb250ZW50ICYmIHJlYWRtZURhdGEuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBCdWZmZXIuZnJvbShyZWFkbWVEYXRhLmNvbnRlbnQsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcclxuICAgICAgcmV0dXJuIGNvbnRlbnQuc2xpY2UoMCwgMjAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIGV2aWRlbmNlIGRhdGEgZm9yIGEgc2luZ2xlIHJlcG9cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVwb0V2aWRlbmNlKHJlcG8sIHRva2VuKSB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VzID0gYXdhaXQgZmV0Y2hSZXBvTGFuZ3VhZ2VzKHJlcG8sIHRva2VuKTtcclxuICBjb25zdCByb290RmlsZXMgPSBhd2FpdCBmZXRjaFJvb3RGaWxlcyhyZXBvLCB0b2tlbik7XHJcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gYXdhaXQgZmV0Y2hEZXBlbmRlbmNpZXMocmVwbywgdG9rZW4pO1xyXG4gIGNvbnN0IGltcG9ydHMgPSBhd2FpdCBmZXRjaEltcG9ydHMocmVwbywgdG9rZW4pO1xyXG4gIGNvbnN0IHJlY2VudENvbW1pdHMgPSBhd2FpdCBmZXRjaFJlY2VudENvbW1pdHMocmVwbywgdG9rZW4pO1xyXG4gIGNvbnN0IHJlYWRtZUV4Y2VycHQgPSBhd2FpdCBmZXRjaFJlYWRtZUV4Y2VycHQocmVwbywgdG9rZW4pO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICByZXBvOiB7XHJcbiAgICAgIG5hbWU6IHJlcG8ubmFtZSxcclxuICAgICAgdXJsOiByZXBvLmh0bWxfdXJsLFxyXG4gICAgICBmb3JrOiByZXBvLmZvcmssXHJcbiAgICAgIHB1c2hlZF9hdDogcmVwby5wdXNoZWRfYXQsXHJcbiAgICB9LFxyXG4gICAgZXZpZGVuY2U6IHtcclxuICAgICAgbGFuZ3VhZ2VzLFxyXG4gICAgICByb290X2ZpbGVzOiByb290RmlsZXMsXHJcbiAgICAgIGRlcGVuZGVuY2llcyxcclxuICAgICAgaW1wb3J0cyxcclxuICAgICAgcmVjZW50X2NvbW1pdHM6IHJlY2VudENvbW1pdHMsXHJcbiAgICAgIHJlYWRtZV9leGNlcnB0OiByZWFkbWVFeGNlcnB0LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogU2NyYXBlIEdpdEh1YiBwcm9maWxlIGFuZCByZXR1cm4gcmVwb3NpdG9yaWVzIGRhdGFcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3JhcGVHaXRIdWJQcm9maWxlKGdpdGh1YlVybCwgZ2l0aHViVG9rZW4gPSBudWxsKSB7XHJcbiAgY29uc3QgdXNlcm5hbWUgPSBleHRyYWN0VXNlcm5hbWUoZ2l0aHViVXJsKTtcclxuICBjb25zdCB0b2tlbiA9IGdpdGh1YlRva2VuIHx8IHByb2Nlc3MuZW52LkdJVEhVQl9UT0tFTiB8fCBudWxsO1xyXG5cclxuICAvLyBGZXRjaCByZXBvc2l0b3JpZXNcclxuICBjb25zdCByZXBvcyA9IGF3YWl0IGZldGNoQWxsUGFnZXMoYC91c2Vycy8ke3VzZXJuYW1lfS9yZXBvc2AsIHRva2VuKTtcclxuXHJcbiAgLy8gRmV0Y2ggZXZpZGVuY2UgZm9yIGFsbCByZXBvc1xyXG4gIGNvbnN0IHJlcG9FdmlkZW5jZSA9IFtdO1xyXG4gIGZvciAoY29uc3QgcmVwbyBvZiByZXBvcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZXZpZGVuY2UgPSBhd2FpdCBmZXRjaFJlcG9FdmlkZW5jZShyZXBvLCB0b2tlbik7XHJcbiAgICAgIHJlcG9FdmlkZW5jZS5wdXNoKGV2aWRlbmNlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJlcG9FdmlkZW5jZS5wdXNoKHtcclxuICAgICAgICByZXBvOiB7XHJcbiAgICAgICAgICBuYW1lOiByZXBvLm5hbWUsXHJcbiAgICAgICAgICB1cmw6IHJlcG8uaHRtbF91cmwsXHJcbiAgICAgICAgICBmb3JrOiByZXBvLmZvcmssXHJcbiAgICAgICAgICBwdXNoZWRfYXQ6IHJlcG8ucHVzaGVkX2F0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZpZGVuY2U6IG51bGwsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQnVpbGQgZW5yaWNoZWQgcmVwb3NcclxuICBjb25zdCBldmlkZW5jZU1hcCA9IG5ldyBNYXAoKTtcclxuICBmb3IgKGNvbnN0IGV2aWRlbmNlRGF0YSBvZiByZXBvRXZpZGVuY2UpIHtcclxuICAgIGV2aWRlbmNlTWFwLnNldChldmlkZW5jZURhdGEucmVwby5uYW1lLCBldmlkZW5jZURhdGEpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZW5yaWNoZWRSZXBvcyA9IHJlcG9zLm1hcChyZXBvID0+IHtcclxuICAgIGNvbnN0IGV2aWRlbmNlRGF0YSA9IGV2aWRlbmNlTWFwLmdldChyZXBvLm5hbWUpO1xyXG4gICAgaWYgKGV2aWRlbmNlRGF0YSkge1xyXG4gICAgICByZXR1cm4gZXZpZGVuY2VEYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVwbzoge1xyXG4gICAgICAgIG5hbWU6IHJlcG8ubmFtZSxcclxuICAgICAgICB1cmw6IHJlcG8uaHRtbF91cmwsXHJcbiAgICAgICAgZm9yazogcmVwby5mb3JrLFxyXG4gICAgICAgIHB1c2hlZF9hdDogcmVwby5wdXNoZWRfYXQsXHJcbiAgICAgIH0sXHJcbiAgICAgIGV2aWRlbmNlOiBudWxsLFxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICdyZXBvc2l0b3JpZXMnLFxyXG4gICAgZGF0YTogZW5yaWNoZWRSZXBvcyxcclxuICB9O1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZG90ZW52Iiwid3JpdGVGaWxlIiwibWtkaXIiLCJyZWFkRmlsZSIsImpvaW4iLCJmaWxlVVJMVG9QYXRoIiwiZGlybmFtZSIsImNvbmZpZyIsIl9fZmlsZW5hbWUiLCJ1cmwiLCJfX2Rpcm5hbWUiLCJHSVRIVUJfQVBJX0JBU0UiLCJleHRyYWN0VXNlcm5hbWUiLCJpbnB1dCIsInRyaW0iLCJsZW5ndGgiLCJFcnJvciIsInRyaW1tZWQiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJtYXRjaCIsInNsaWNlIiwiZmV0Y2hHaXRIdWJBUEkiLCJlbmRwb2ludCIsInRva2VuIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiZmV0Y2hBbGxQYWdlcyIsImFsbEl0ZW1zIiwicGFnZSIsInBlclBhZ2UiLCJzZXBhcmF0b3IiLCJwYWdpbmF0ZWRFbmRwb2ludCIsIml0ZW1zIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsImZldGNoUmVwb0xhbmd1YWdlcyIsInJlcG8iLCJsYW5ndWFnZXNVcmwiLCJsYW5ndWFnZXNfdXJsIiwicmVwbGFjZSIsImxhbmd1YWdlcyIsImVycm9yIiwiZmV0Y2hSb290RmlsZXMiLCJjb250ZW50c1VybCIsImNvbnRlbnRzX3VybCIsImNvbnRlbnRzIiwiZmlsdGVyIiwiaXRlbSIsInR5cGUiLCJtYXAiLCJuYW1lIiwiZmV0Y2hSZWNlbnRDb21taXRzIiwiY29tbWl0c1VybCIsImNvbW1pdHNfdXJsIiwiY29tbWl0cyIsImNvbW1pdCIsImF1dGhvciIsImxvZ2luIiwiZGF0ZSIsImNvbW1pdHRlciIsIm1lc3NhZ2UiLCJmZXRjaERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lGaWxlcyIsImRlcEZpbGUiLCJmaWxlIiwiZmluZCIsImRvd25sb2FkX3VybCIsImZpbGVDb250ZW50IiwidGhlbiIsInIiLCJ0ZXh0IiwicGtnIiwiSlNPTiIsInBhcnNlIiwiZGVwcyIsImRldkRlcGVuZGVuY2llcyIsIk9iamVjdCIsImtleXMiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInBrZ05hbWUiLCJlcnIiLCJmZXRjaEltcG9ydHMiLCJpbXBvcnRzIiwiU2V0Iiwic291cmNlRXh0ZW5zaW9ucyIsInNvbWUiLCJleHQiLCJlbmRzV2l0aCIsImpzSW1wb3J0IiwiYWRkIiwicHlJbXBvcnQiLCJqYXZhSW1wb3J0Iiwic2l6ZSIsImZyb20iLCJmZXRjaFJlYWRtZUV4Y2VycHQiLCJyZWFkbWVGaWxlIiwidG9Mb3dlckNhc2UiLCJyZWFkbWVFbmRwb2ludCIsInJlYWRtZUVuZHBvaW50UGF0aCIsInJlYWRtZURhdGEiLCJjb250ZW50IiwiZW5jb2RpbmciLCJCdWZmZXIiLCJ0b1N0cmluZyIsImZldGNoUmVwb0V2aWRlbmNlIiwicm9vdEZpbGVzIiwicmVjZW50Q29tbWl0cyIsInJlYWRtZUV4Y2VycHQiLCJodG1sX3VybCIsImZvcmsiLCJwdXNoZWRfYXQiLCJldmlkZW5jZSIsInJvb3RfZmlsZXMiLCJyZWNlbnRfY29tbWl0cyIsInJlYWRtZV9leGNlcnB0Iiwic2NyYXBlR2l0SHViUHJvZmlsZSIsImdpdGh1YlVybCIsImdpdGh1YlRva2VuIiwidXNlcm5hbWUiLCJwcm9jZXNzIiwiZW52IiwiR0lUSFVCX1RPS0VOIiwicmVwb3MiLCJyZXBvRXZpZGVuY2UiLCJldmlkZW5jZU1hcCIsIk1hcCIsImV2aWRlbmNlRGF0YSIsInNldCIsImVucmljaGVkUmVwb3MiLCJnZXQiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/github-scraper.mjs\n");

/***/ })

};
;